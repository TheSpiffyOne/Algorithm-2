# Реализация рекурсивной функции для вычисления степени числа
## Принцип работы

Функция работает по принципу математической рекурсии:
- **Базовый случай**: когда степень n = 0, результат всегда равен 1
- **Отрицательная степень**: преобразуется в положительную через обратную величину
- **Рекурсивный случай**: xⁿ = x × xⁿ⁻¹

**Пример выполнения power(2, 3):**
1. power(2, 3) = 2 × power(2, 2)
2. power(2, 2) = 2 × power(2, 1)
3. power(2, 1) = 2 × power(2, 0)
4. power(2, 0) = 1 (базовый случай)
5. Возврат: 2 × 1 = 2 → 2 × 2 = 4 → 2 × 4 = 8

## Анализ синтаксиса по пунктам

### C++:
- **Функция**: `double power(double x, int n)` - тип возвращаемого значения и параметров
- **Условия**: `if (n == 0)` - проверка базового случая
- **Рекурсия**: `return x * power(x, n - 1)` - рекурсивный вызов
- **Обработка отрицательной степени**: `return 1 / power(x, -n)`

### Java:
- **Модификатор доступа**: `public static` - метод доступен без создания объекта
- **Типизация**: строгая типизация как в C++
- **Рекурсивный вызов**: аналогичен C++ синтаксису

### Python:
- **Определение функции**: `def power(x, n):` - без указания типов
- **Отступы**: вместо фигурных скобок используются отступы
- **Условные операторы**: `if n == 0:` с двоеточием
- **Динамическая типизация**: типы определяются во время выполнения

## Временная сложность

**Временная сложность: O(n)**

**Объяснение:**
Временная сложность O(n) возникает в связи с тем, что функция совершает ровно n рекурсивных вызовов для вычисления xⁿ. Каждый вызов уменьшает степень на 1, пока не достигнет базового случая (n=0).

Для отрицательных степеней сложность также O(|n|), так как функция сначала преобразует отрицательную степень в положительную, затем выполняет |n| рекурсивных вызовов.

## Ответ на контрольный вопрос
Чем отличаются перестановки от сочетаний?

Перестановки — это различные способы расположения всех элементов множества с учётом порядка.
Сочетания — это выбор нескольких элементов из множества без учёта порядка.
Иными словами, в перестановках порядок важен (ABC ≠ BAC), а в сочетаниях — нет (ABC = BAC).
