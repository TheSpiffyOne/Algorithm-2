# Вариант 2. Жадный алгоритм для составления расписания

1) Пошаговый анализ кода

```cpp
// 1) Чтение входных данных
int n; // число машин
int m; // число работ
vector<int> jobs(m);
cin >> n >> m;
for i = 0..m-1: cin >> jobs[i];

// 2) Подготовка LPT: сортируем jobs по убыванию длительности,
//    сохраняя исходный индекс (job index).
vector<pair<int,int>> sorted = [(index, duration) ...];
sort(sorted.begin(), sorted.end(), cmp_by_duration_desc);

// 3) Для распределения используем мин-кучу (priority_queue min) по (текущая_загрузка, индекс_машины)
priority_queue<pair<int,int>, ..., greater<>> pq;
for each machine i: pq.push({0, i});

// 4) Итерируем jobs в порядке убывания длительности:
//    - извлекаем машину с минимальной загрузкой: (load, machine) = pq.top(); pq.pop();
//    - назначаем работу: loads[machine] += job_duration;
//    - добавляем запись в machine_jobs[machine]
//    - возвращаем в очередь обновлённую пару (loads[machine], machine)
for each (job_idx, dur) in sorted:
    (load, machine) = pq.pop();
    loads[machine] += dur;
    machine_jobs[machine].push_back({job_idx+1, dur});
    pq.push({loads[machine], machine});

// 5) Результат: makespan = max(loads)
// 6) Дополнительно: если пространство перебора n^m небольшое, делаем brute-force через рекурсию:
//    dfs(pos): для каждой машины назначаем job[pos] и рекурсивно dfs(pos+1)
//    при pos==m вычисляем max(loads) и обновляем best_makespan
```

---

 2) Временная сложность в худшем случае

* LPT (жадный) часть:

  * Сортировка `m` работ по убыванию: `O(m log m)`.
  * Для каждой из `m` работ делаем извлечение и вставку в мин-кучу размером `n`: каждая операция `O(log n)`, итого `O(m log n)`.
  * В сумме: `O(m log m + m log n)`.

* Перебор (brute-force) для точного решения:

  * Полный перебор всех назначений: `n^m` вариантов; для каждого варианта нужно обновить/проверить загрузки `O(m)` — в результате `O(m * n^m)`.
  * Поэтому практическая граница маленьких `m` (например m ≤ 12 при n невеликом) — важна.

---

 3) Пояснение, почему возникает именно такая временная сложность

* `O(m log m)` — потому что мы сортируем список из `m` работ алгоритмом сравнения (std::sort использует быстрый сорт, требующий `O(m log m)` сравнений в худшем/среднем).
* `O(m log n)` — потому что для каждого из `m` назначений мы поддерживаем мин-кучу машин размера `n`: извлечение/вставка в кучу стоит `O(log n)`. Эти две составляющие суммируются, давая `O(m log m + m log n)`.
* Брутфорс `O(m * n^m)` возникает потому, что каждое из `m` работ может быть назначено на любую из `n` машин (всего `n^m` распределений), и при проверке одного распределения нужно просуммировать и/или проверить загрузки (линейно по `m`).

---

 4) Коэффициент аппроксимации - Дайте определение коэффициента аппроксимации α для задачи минимизации. Что он характеризует?

Коэффициент аппроксимации α (alpha) для задачи минимизации — это константа α ≥ 1 такая, что для любого входа алгоритм гарантированно возвращает решение с целевой функцией не более α раз хуже оптимального: `ALG(I) ≤ α * OPT(I)`. Он характеризует качество приближённого алгоритма: чем ближе α к 1, тем лучше приближение. Для задач NP-трудных обычно ищут алгоритмы с малым конечным α (гарантированным приближением).

---

 5) Результат работы программы для указанных входных данных

Вход:

* Число машин: `3`
* Длительности работ: `[5, 7, 3, 8, 2, 6, 4, 9, 1, 5]`
  (в порядке job1..job10)

**Greedy LPT (результат):**

* Machine 1 (load=17): [job8=9] [job10=5] [job5=2] [job9=1]
* Machine 2 (load=17): [job4=8] [job1=5] [job7=4]
* Machine 3 (load=16): [job2=7] [job6=6] [job3=3]
* Greedy makespan = **17**

**Оптимальное (перебор) для этого входа:**

* Optimal makespan = **17** (для ваших данных жадный LPT дал оптимальный результат).
