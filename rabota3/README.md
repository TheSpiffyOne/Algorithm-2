# Вариант 2. Жадный алгоритм для составления расписания

# Результат выполнения кода для входных данных
Вход:

* Число машин: `3`
* Длительности работ: `[5, 7, 3, 8, 2, 6, 4, 9, 1, 5]`

Жадный алгоритм LPT (наш код назначает большие задачи в первую очередь на наименее загруженную машину):

* Машина 0: работы `[9, 5, 2, 1]`, суммарно `17`
* Машина 1: работы `[8, 5, 4]`, суммарно `17`
* Машина 2: работы `[7, 6, 3]`, суммарно `16`
* Makespan (жадный): `17`

Полный перебор (оптимум) для этого входа (3^10 = 59 049 вариантов — перебор допустим) даёт:

* Оптимальное распределение (один из оптимальных):

  * Машина 0: `[5,7,3,2]` → `17`
  * Машина 1: `[8,4,5]` → `17`
  * Машина 2: `[6,9,1]` → `16`
* Makespan (оптимум): `17`

Вывод: в данном примере жадный алгоритм LPT дал **оптимальный** makespan = **17** (α = 1 на этом входе).

#  Анализ кода
1. Сначала сортируем работы по убыванию длительности (LPT — Longest Processing Time first) `jobs_sorted`
2. Для каждой машины заводим счетчик нагрузки `loads` и список назначенных работ `assignment`
3. Проходим по каждой работе `job` в `jobs_sorted` по порядку убывания:
     a) ищем машину с наименьшей суммарной нагрузкой
     b) назначаем работу на эту машину
     c) обновляем нагрузку машины
4. После распределения всех работ находим максимальную загрузку среди машин — это `makespan`
5. Возвращаем назначение работ, загрузки машин и значение `makespan`
   * добавить job в `assignment[i]`
    увеличить `loads[i]` на `job`;
    return `assignment`, `loads`, `makespan`

# Временная сложность (в худшем случае)

* Для LPT (реализация в коде): **O(J log J + J * M)**, где J — число работ (jobs), M — число машин (num_machines).

  * объяснение: сортировка занимает O(J log J), а для каждой из J работ мы делаем `loads.index(min(loads))`, то есть поиск минимума по списку длины M — O(M) на работу, в сумме O(J*M).
* Для полного перебора (optimal_schedule_bruteforce): **O(M^J * J)** в худшем случае.

  * объяснение: есть M^J возможных распределений; для каждого распределения нужно просуммировать J работ по машинам → O(J) работа.

# Пояснение, почему такая временная сложность возникла (худший случай)

* Сортировка по убыванию длительностей (LPT) использует стандартный алгоритм сортировки с асимптотикой O(J log J) — это носитель основной работы по упорядочению задач по приоритету.
* После сортировки для каждой работы алгоритм ищет машину с минимальной загрузкой, реализовано как линейный поиск по списку машин длины M — этот поиск даёт множитель M на каждую из J работ, что даёт вклад O(J*M). Если бы мы вместо линейного поиска использовали мин-кучу по машинам (heap), то поиск и обновление заняли бы O(log M) на работу и общая сложность стала бы O(J log J + J log M).
* Для полного перебора причина экспоненциальной сложности — это необходимость проверить все возможные назначение каждой из J работ на одну из M машин, всего M^J вариантов; для каждого варианта считаем суммарные загрузки (затраты O(J)) → O(M^J * J).

# Коэффициент аппроксимации - Дайте определение коэффициента аппроксимации α для задачи минимизации. Что он характеризует?

Коэффициент аппроксимации α (alpha) для алгоритма приближения в задаче минимизации — это число α ≥ 1 такое, что для любого входа значение целевой функции, найденное алгоритмом (ALG), не превосходит α умноженное на оптимальное значение (OPT): ALG ≤ α · OPT. α характеризует, насколько худший результат алгоритма может отличаться от оптимального: чем ближе α к 1, тем точнее (лучше) приближение; α = 1 означает, что алгоритм всегда находит оптимум.

