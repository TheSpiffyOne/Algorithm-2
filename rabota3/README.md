# Вариант 2. Жадный алгоритм для составления расписания

1) Пошаговый анализ кода
1. Ввод и проверка данных
   Программа начинает с запроса числа машин `n` и числа работ `m`. Затем она читает `m` чисел — длительности работ в вектор `jobs`. Если пользователь ввёл некорректные значения (например, `n <= 0` или `m <= 0`), программа корректно завершит работу. На этом этапе переменные `n`, `m` и массив `jobs` содержат всё, что нужно для решения задачи.

2. Подготовка списка работ для LPT (Longest Processing Time)
   Для жадного алгоритма LPT мы хотим сначала распределить самые долгие работы. Поэтому программа формирует список пар `(index, duration)` для каждой работы и сортирует этот список по убыванию длительности. После сортировки самый длинный джоб — в начале списка. Инвариант: в отсортированном списке продолжительности идут не возрастающей последовательностью; индексы сохраняют оригинальную нумерацию работ.

3. Инициализация структур для распределения
   Для отслеживания текущей загрузки каждой машины используется массив `loads` размером `n`, инициализированный нулями. Для хранения конкретных назначенных работ на каждую машину используется `machine_jobs` — массив векторов. Кроме того, создаётся мин-куча (priority queue), ключ в которой — пара `(текущая_загрузка, индекс_машины)`. В мин-куче на вершине всегда машина с наименьшей текущей загрузкой. Изначально в очередь помещаются `n` пар `(0, i)`.

4. Итерация по работам в порядке убывания длительности
   Программа проходит по отсортированному списку работ: для каждой работы извлекает из мин-кучи машину с минимальной загрузкой, присоединяет работу к этой машине (добавляет длительность в `loads[machine]` и записывает информацию о работе в `machine_jobs[machine]`), затем возвращает эту машину в кучу с обновлённой загрузкой. Инвариант после каждой итерации: мин-куча корректно отражает текущие загрузки всех машин, поэтому следующая работа попадёт на машину, которая в данный момент наименее загружена.

5. Почему LPT использует сортировку + мин-кучу
   Сортировка обеспечивает, что крупные (долгие) работы назначаются раньше, чтобы не образовать «горб» из нескольких больших работ на одной машине в конце. Мин-куча даёт быстрый доступ к машине с наименьшей загрузкой (вставка/извлечение — `O(log n)`), поэтому каждое назначение выполняется эффективно.

6. Вычисление результата жадного алгоритма (makespan)
   После распределения всех работ программа ищет максимум по массиву `loads` — это makespan (время завершения расписания). Этот максимум печатается вместе с детальным списком работ для каждой машины (какие номера работ и их длительности).

7. Переборный (brute-force) поиск оптимума для малого входа
   Чтобы сравнить качество жадного решения с оптимальным, программа пытается выполнить полный перебор всех возможных назначений, но только если размер пространства перебора `n^m` не слишком большой (в коде — порог ~5e6). Перебор реализован рекурсивно: на шаге `pos` рекурсии назначается работа `pos` на каждую из `n` машин и рекурсия идёт дальше. При достижении `pos == m` вычисляется максимальная загрузка и, при необходимости, обновляется лучший найденный makespan.

8. Почему проверка перебора ограничена (практическая причина)
   Пространство всех распределений равно `n^m`. Если `m` и `n` не очень малы, перебор экспоненциально растёт и становится невыполнимым по времени. Поэтому программа оценивает `n^m` и пропускает полный перебор, если пространства слишком велико — это предотвращает «подвешивание» программы.

9. Временная сложность (текстовое объяснение)

   * Сортировка даёт `O(m log m)` потому что сравнивается `m` элементов и стандартный алгоритм сортировки имеет такую сложность.
   * Каждая из `m` итераций назначения делает одно извлечение и одну вставку в мин-кучу размера `n`, каждая такая операция `O(log n)`, значит суммарно `O(m log n)`.
   * Полный перебор всех назначений — `n^m` комбинаций; для каждой комбинации нужно (явно или неявно) суммировать нагрузки/проверить максимум, что даёт множитель `m` и итог `O(m * n^m)`.
     В сумме жадная часть: `O(m log m + m log n)`. Брутфорс (при включении) доминирует и делает время экспоненциальным.

10. Память и дополнительные ресурсы
    Основные структуры — массив `jobs` длины `m`, массив `loads` длины `n`, `machine_jobs` содержащий `m` записей в сумме, и мин-куча с `n` элементами. Память порядка `O(m + n)`. Переборная рекурсия использует стек глубины `m`, то есть дополнительная стековая память `O(m)`.

11. Корректность и инварианты на разных этапах

    * Перед началом распределения: все `loads[i] == 0`.
    * После каждой операции извлечения/назначения: сумма всех `loads` равна сумме длительностей всех уже назначенных работ.
    * Мин-куча всегда корректно отражает текущие загрузки машин, поэтому распределение следует жадной стратегии «положи следующую (самую длинную) работу на наименее загруженную машину».

12. Граничные случаи и поведение программы

    * `n >= m`: если машин больше или равно числу работ, то первые `m` машин получат по одной работе и makespan будет равен максимальной длительности работы.
    * Очень длинная работа: LPT гарантированно поместит её первой на пустую машину, так что она не «поглотит» суммарно другие работы на той же машине (по крайней мере, будет учтена в начале).
    * Нулевые или отрицательные длительности: программа не защищена явно от отрицательных значений; корректнее было бы проверять входы и требовать ненулевые положительные длительности.

13. Возможные улучшения и оптимизации

    * Отсечение в переборе: при рекурсивном переборе можно прерывать ветку, когда текущая максимальная загрузка уже ≥ лучшего найденного, это значительно сокращает поиск.
    * Балансировка при равных загрузках: при извлечении из кучи можно предпочитать машины с меньшим индексом — это влияет лишь на детальные назначения, но не на makespan.
    * Для очень больших `m` и `n` можно применять более сложные эвристики или метаэвристики (например, локальный поиск, симулированный отжиг), либо использовать ILP/динамическое программирование для специальных случаев.

14. Поведение на ваших входных данных (короткое пояснение результатов)
    Для `n = 3` и `jobs = [5,7,3,8,2,6,4,9,1,5]` жадный LPT сначала сортирует работы по убыванию (9,8,7,6,5,5,4,3,2,1), затем последовательно кладёт каждую на текущую минимальную машину. В результате получаем загрузки `[17,17,16]`, makespan = 17. Перебор для такого размера пространства (3^10 = 59049) возможен и показывает, что оптимум тоже равен 17, т.е. жадный алгоритм в данном случае дал оптимальный результат.

15. Итог (кратко)
    Программа читает данные, сортирует работы по убыванию, использует мин-кучу машин, чтобы жадно класть каждую следующую (самую длинную) работу на наименее загруженную машину, затем вычисляет makespan. Для малых входов дополнительно выполняется полный перебор, чтобы найти оптимальный makespan и сравнить с результатом жадного алгоритма. Временная сложность жадной части — `O(m log m + m log n)`, перебор — экспоненциальный `O(m * n^m)`.

Если хотите, могу преобразовать этот текст в документ (PDF или markdown) или дать короткую распечатку того, какие конкретно шаги выполнялись для каждого присвоения при вашем наборе работ (т.е. расписать 10 итераций LPT одну за другой). Какой формат предпочтёте?

---

 2) Временная сложность в худшем случае

* LPT (жадный) часть:

  * Сортировка `m` работ по убыванию: `O(m log m)`.
  * Для каждой из `m` работ делаем извлечение и вставку в мин-кучу размером `n`: каждая операция `O(log n)`, итого `O(m log n)`.
  * В сумме: `O(m log m + m log n)`.

* Перебор (brute-force) для точного решения:

  * Полный перебор всех назначений: `n^m` вариантов; для каждого варианта нужно обновить/проверить загрузки `O(m)` — в результате `O(m * n^m)`.
  * Поэтому практическая граница маленьких `m` (например m ≤ 12 при n невеликом) — важна.

---

 3) Пояснение, почему возникает именно такая временная сложность

* `O(m log m)` — потому что мы сортируем список из `m` работ алгоритмом сравнения (std::sort использует быстрый сорт, требующий `O(m log m)` сравнений в худшем/среднем).
* `O(m log n)` — потому что для каждого из `m` назначений мы поддерживаем мин-кучу машин размера `n`: извлечение/вставка в кучу стоит `O(log n)`. Эти две составляющие суммируются, давая `O(m log m + m log n)`.
* Брутфорс `O(m * n^m)` возникает потому, что каждое из `m` работ может быть назначено на любую из `n` машин (всего `n^m` распределений), и при проверке одного распределения нужно просуммировать и/или проверить загрузки (линейно по `m`).

---

 4) Коэффициент аппроксимации - Дайте определение коэффициента аппроксимации α для задачи минимизации. Что он характеризует?

Коэффициент аппроксимации α (alpha) для задачи минимизации — это константа α ≥ 1 такая, что для любого входа алгоритм гарантированно возвращает решение с целевой функцией не более α раз хуже оптимального: `ALG(I) ≤ α * OPT(I)`. Он характеризует качество приближённого алгоритма: чем ближе α к 1, тем лучше приближение. Для задач NP-трудных обычно ищут алгоритмы с малым конечным α (гарантированным приближением).

---

 5) Результат работы программы для указанных входных данных

Вход:

* Число машин: `3`
* Длительности работ: `[5, 7, 3, 8, 2, 6, 4, 9, 1, 5]`
  (в порядке job1..job10)

**Greedy LPT (результат):**

* Machine 1 (load=17): [job8=9] [job10=5] [job5=2] [job9=1]
* Machine 2 (load=17): [job4=8] [job1=5] [job7=4]
* Machine 3 (load=16): [job2=7] [job6=6] [job3=3]
* Greedy makespan = **17**

**Оптимальное (перебор) для этого входа:**

* Optimal makespan = **17**
