# Вариант 2. Жадный алгоритм для составления расписания

## 1) Пошаговый анализ кода

1. **Использование условия `if (n == 0)`**
   — синтаксис `if` задаёт базовый случай рекурсии.
   — при выполнении условия результат вычисления возвращается сразу через `return 1`, без дальнейших вызовов.
   — это точка остановки рекурсии.

2. **Использование рекурсивного вызова `power(x, n - 1)`**
   — синтаксис вызова функции с уменьшенным аргументом создаёт новую копию функции в стеке.
   — каждый вызов уменьшает `n`, поэтому последовательность вызовов обязательно дойдёт до условия `if (n == 0)`.
   — рекурсивная цепочка полностью определяется оператором вызова самого себя.

3. **Использование оператора умножения `x * ...`**
   — синтаксис бинарной операции `*` создаёт накопление результата:
   значение поднимается вверх по стеку, каждый уровень домножает `x` один раз.
   — так формируется итоговая формула:
   `x * x * x * ...` (n раз).

4. **Использование оператора `return`**
   — синтаксис `return` завершает текущий стековый кадр и передаёт значение обратному вызову.
   — когда достигается базовый случай, цепочка `return` запускает обратное сворачивание, и вычисление переходит наверх, до самого первого вызова.

5. **Рекурсивная структура благодаря синтаксису «уменьшай и верни»**
   — комбинация

   ```
   if (...)
       return ...
   return x * power(x, n - 1);
   ```

   задаёт рекурсивную формулу:
   x^n=x⋅x^n−1.
   — весь алгоритм строится именно на этом синтаксическом паттерне:
   **условие + рекурсивный вызов + возврат значения**.

## 2) Временная сложность в худшем случае

* LPT (жадный) часть:

  * Сортировка `m` работ по убыванию: `O(m log m)`.
  * Для каждой из `m` работ делаем извлечение и вставку в мин-кучу размером `n`: каждая операция `O(log n)`, итого `O(m log n)`.
  * В сумме: `O(m log m + m log n)`.

* Перебор (brute-force) для точного решения:

  * Полный перебор всех назначений: `n^m` вариантов; для каждого варианта нужно обновить/проверить загрузки `O(m)` — в результате `O(m * n^m)`.
  * Поэтому практическая граница маленьких `m` (например m ≤ 12 при n невеликом) — важна.

---

## 3) Пояснение, почему возникает именно такая временная сложность

* `O(m log m)` — потому что мы сортируем список из `m` работ алгоритмом сравнения (std::sort использует быстрый сорт, требующий `O(m log m)` сравнений в худшем/среднем).
* `O(m log n)` — потому что для каждого из `m` назначений мы поддерживаем мин-кучу машин размера `n`: извлечение/вставка в кучу стоит `O(log n)`. Эти две составляющие суммируются, давая `O(m log m + m log n)`.
* Брутфорс `O(m * n^m)` возникает потому, что каждое из `m` работ может быть назначено на любую из `n` машин (всего `n^m` распределений), и при проверке одного распределения нужно просуммировать и/или проверить загрузки (линейно по `m`).

---

## 4) Коэффициент аппроксимации - Дайте определение коэффициента аппроксимации α для задачи минимизации. Что он характеризует?

Коэффициент аппроксимации α (alpha) для задачи минимизации — это константа α ≥ 1 такая, что для любого входа алгоритм гарантированно возвращает решение с целевой функцией не более α раз хуже оптимального: `ALG(I) ≤ α * OPT(I)`. Он характеризует качество приближённого алгоритма: чем ближе α к 1, тем лучше приближение. Для задач NP-трудных обычно ищут алгоритмы с малым конечным α (гарантированным приближением).

---

## 5) Результат работы программы для указанных входных данных

Вход:

* Число машин: `3`
* Длительности работ: `[5, 7, 3, 8, 2, 6, 4, 9, 1, 5]`
  (в порядке job1..job10)

**Greedy LPT (результат):**

* Machine 1 (load=17): [job8=9] [job10=5] [job5=2] [job9=1]
* Machine 2 (load=17): [job4=8] [job1=5] [job7=4]
* Machine 3 (load=16): [job2=7] [job6=6] [job3=3]
* Greedy makespan = **17**

**Оптимальное (перебор) для этого входа:**

* Optimal makespan = **17**
